## 1

### 문제 - <code>덧칠하기</code>

### 알고리즘 설계

(왜 이렇게 코드를 작성했는지 이유를 적어주세요)

1. section 배열의 각 원소(구역의 시작 지점)를 순회합니다.
2. 현재 구역이 part (현재까지 칠한 구역의 끝 지점)보다 큰지 확인합니다.
   • n > part 조건이 참이면, 현재 구역을 페인트칠해야 합니다.
3. 현재 구역을 페인트칠하고, part 변수를 업데이트합니다.
   • part = n + m - 1로 현재 구역의 끝 지점을 계산하여 part에 저장합니다.
4. 페인트를 칠했으므로 answer 변수를 1 증가시킵니다.
5. 배열의 모든 원소를 순회한 후, 최종적으로 answer 값을 반환합니다.

### 풀이 코드

```
function solution(n, m, section) {
  let answer = 0;

  // 현재까지 칠한 구역
  let part = 0;

  // section을 forEach() 메서드로 하나씩 확인한다.
  section.forEach((n) => {

    // 현재 구역이 현재까지 칠한 구역보다 크다면
    if (n > part) {

      // 구역을 칠해주고 현재까지 칠한 구역을 업데이트 시켜준다.
      part = n + m - 1;
      // 페인트를 칠했으니 1증가 시킨다.
      answer++;
    }
  });

  return answer;
}
```

### 개인적인 회고와 다른 풀이

(풀이 중 힘든 점이 있었다면 왜 힘들었고 어떻게 해결했는지, 아니면 이외의 좋을 것 같은 다른 풀이법이 있다면 같이 작성해주세요)

### 느낀 점

(풀면서 느낀점 이외에도 기억할 점이나 같이 논의하고 싶은 부분 등이 있다면 자유롭게 적어주세요)

문제를 읽었을 때 뭔가 헷갈렸는데 좀 단순하게 접근하니 풀렸던 문제였습니다.

## 2

### 문제 - <code>실패율</code>

### 알고리즘 설계

(왜 이렇게 코드를 작성했는지 이유를 적어주세요)

1. for 루프를 사용하여 1부터 N까지의 각 스테이지 번호에 대해 반복합니다.
2. reach: 해당 스테이지에 도달한 플레이어 수를 계산합니다. (해당 스테이지 이상인 플레이어 수)
   • stages.filter((x) => x >= i).length는 스테이지 i 이상에 도달한 플레이어 수를 셉니다.
3. curr: 해당 스테이지에 머물러 있는 플레이어 수를 계산합니다.
   • stages.filter((x) => x === i).length는 현재 스테이지 i에서 도전 중인 플레이어 수를 셉니다.
4. result 배열에 스테이지 번호와 실패율(= curr / reach)을 추가합니다.
   • 실패율은 현재 스테이지에서 도전 중인 플레이어 수를 해당 스테이지 이상 도달한 플레이어 수로 나눈 값입니다.
5. result 배열을 실패율을 기준으로 내림차순으로 정렬합니다.
6. 정렬된 result 배열에서 스테이지 번호만 추출하여 반환합니다.

### 풀이 코드

```
function solution(N, stages) {
    let result = [];

    for(let i = 1; i <= N; i++) {
        let reach = stages.filter((x) => x >= i).length;  // 스테이지 i에 도달한 플레이어 수
        let curr = stages.filter((x) => x === i).length;  // 스테이지 i에서 머물러 있는 플레이어 수
        result.push([i, curr / reach]);  // 스테이지 번호와 실패율을 배열에 추가
    }

    result.sort((a, b) => b[1] - a[1]);  // 실패율에 따라 내림차순으로 정렬
    return result.map((x) => x[0]);  // 정렬된 스테이지 번호만 추출하여 반환
}
```

### 개인적인 회고와 다른 풀이

(풀이 중 힘든 점이 있었다면 왜 힘들었고 어떻게 해결했는지, 아니면 이외의 좋을 것 같은 다른 풀이법이 있다면 같이 작성해주세요)

### 느낀 점

(풀면서 느낀점 이외에도 기억할 점이나 같이 논의하고 싶은 부분 등이 있다면 자유롭게 적어주세요)

실패율을 계산해서 순위를 매기는 것보다 스테이지 번호를 출력하는 것이 고민이었습니다. 배열 안에 실패율과 스테이지 번호를 함께 넣음으로서 해결했습니다.

## 3

### 문제 - <code>대충 만든 자판</code>

### 알고리즘 설계

(왜 이렇게 코드를 작성했는지 이유를 적어주세요)

1. 각 타겟 문자열에 대해 반복합니다.
2. 각 타겟 문자열의 각 문자를 순회하며 처리합니다.
3. 각 키맵 행에 대해 문자의 인덱스를 찾고, 이를 indexArr에 추가합니다.
   • 인덱스는 1부터 시작하도록 +1을 합니다.
4. indexArr에서 최소값을 찾아 minIndex에 저장합니다.
   • minIndex가 10001이면 해당 문자가 키맵에 없다는 의미입니다.
5. 문자가 키맵에 없으면 sum을 -1로 설정하고, 해당 타겟 문자열의 처리를 중단합니다.
6. 그렇지 않으면 sum에 minIndex를 누적합니다.
7. 모든 문자를 처리한 후, sum을 result 배열에 추가합니다.
8. 모든 타겟 문자열에 대해 반복이 끝나면, result 배열을 반환합니다.

### 풀이 코드

```
function solution(keymap, targets) {
    let result = [];

    targets.forEach(target => {
        let sum = 0;

        for (let i = 0; i < target.length; i++) {
            let indexArr = [10001];  // 각 문자의 인덱스를 저장하는 배열을 초기화

            for (let j = 0; j < keymap.length; j++) {
                let index = keymap[j].indexOf(target[i]);
                if (index >= 0) {
                    indexArr.push(index + 1);  // 인덱스는 1부터 시작하므로 +1
                }
            }

            let minIndex = Math.min(...indexArr);

            if (minIndex === 10001) {  // 키맵에 문자가 없는 경우
                sum = -1;
                break;  // 현재 타겟 문자열에 대해 더 이상 계산할 필요가 없음
            } else {
                sum += minIndex;
            }
        }

        result.push(sum);
    });

    return result;
}
```

### 개인적인 회고와 다른 풀이

(풀이 중 힘든 점이 있었다면 왜 힘들었고 어떻게 해결했는지, 아니면 이외의 좋을 것 같은 다른 풀이법이 있다면 같이 작성해주세요)

### 느낀 점

(풀면서 느낀점 이외에도 기억할 점이나 같이 논의하고 싶은 부분 등이 있다면 자유롭게 적어주세요)

딱히 묘수가 떠오르지 않아 타겟 원소 처음 부터 시작해서 키맵을 전부 순회했습니다 더 효율적인 코드가 있을 거 같습니다..
