## 1

### 문제 - <code>폰켓몬</code>

### 알고리즘 설계

(왜 이렇게 코드를 작성했는지 이유를 적어주세요)

1.	고유한 폰켓몬의 수 계산 (uniqueCount):
	•	new Set(nums)를 사용하여 nums 배열에서 중복된 원소를 제거합니다. Set은 고유한 값만을 저장하기 때문에, Set의 크기는 배열 내 고유한 폰켓몬의 수를 의미합니다.
	•	size 속성을 사용하여 Set의 크기를 계산합니다. 이 값은 uniqueCount 변수에 저장됩니다.
2.	가져갈 수 있는 최대 폰켓몬의 수 계산 (maxAllowed):
	•	문제에서 폰켓몬의 절반만 가져갈 수 있다고 명시했으므로, nums.length / 2를 계산하여 가져갈 수 있는 최대 폰켓몬의 수를 maxAllowed 변수에 저장합니다.
3.	최종 반환 값 계산 및 반환:
	•	고유한 폰켓몬의 수와 최대 가져갈 수 있는 폰켓몬의 수 중 작은 값을 반환합니다. Math.min(uniqueCount, maxAllowed)를 사용하여 이 값을 계산합니다.
	•	이렇게 함으로써, 고유한 폰켓몬의 수가 전체의 절반보다 많다면 절반만큼만 가져갈 수 있게 되고, 그렇지 않다면 고유한 폰켓몬의 수만큼 가져가게 됩니다.

### 풀이 코드

```
function solution(nums) {
    const uniqueCount = new Set(nums).size;  // 1. 중복된 원소를 제거하여 고유한 폰켓몬의 수를 계산합니다.
    const maxAllowed = nums.length / 2;      // 2. 전체 폰켓몬의 절반만큼 가져갈 수 있으므로 배열 길이의 절반을 계산합니다.
    
    return Math.min(uniqueCount, maxAllowed); // 3. 고유한 폰켓몬의 수와 최대 가져갈 수 있는 폰켓몬의 수 중 작은 값을 반환합니다.
}
```

### 개인적인 회고와 다른 풀이

(풀이 중 힘든 점이 있었다면 왜 힘들었고 어떻게 해결했는지, 아니면 이외의 좋을 것 같은 다른 풀이법이 있다면 같이 작성해주세요)

### 느낀 점

(풀면서 느낀점 이외에도 기억할 점이나 같이 논의하고 싶은 부분 등이 있다면 자유롭게 적어주세요)


## 2

### 문제 - <code>크레인 인형뽑기</code>

### 알고리즘 설계

(왜 이렇게 코드를 작성했는지 이유를 적어주세요)
1.	보드 트랜스포즈:
    •   트랜포즈는 배열의 행과 열을 뒤집는 것입니다
	•	이 과정에서는 board 배열을 세로로 읽어서 board1 배열에 저장합니다. 
	•	이중 for 루프를 사용하여, board[j][i]의 값을 읽고, 값이 0이 아닌 경우에만 tmpArr에 추가합니다.
	•	tmpArr 배열은 각 열을 나타내며, 이 배열을 board1에 추가합니다.
2.	바구니에 인형 추가 및 제거:
	•	moves 배열의 각 움직임을 처리합니다.
	•	moves 배열의 각 요소 e는 크레인의 움직임을 나타내며, 이는 인덱스 e-1로 변환되어(0이 없기 때문) board1 배열의 해당 열에 접근합니다.
	•	board1[e-1]이 유효한 배열이고 비어 있지 않은 경우, 첫 번째 아이템을 item 변수에 저장합니다.
	•	shift() 메서드를 사용하여 첫 번째 아이템을 board1[e-1] 배열에서 제거합니다.
	•	basket 배열의 마지막 아이템과 현재 아이템이 동일한지 확인합니다.
	•	동일하면 basket 배열의 마지막 아이템을 제거하고, result를 2 증가시킵니다.
	•	동일하지 않으면 현재 아이템을 basket 배열에 추가합니다.

### 풀이 코드

```
function solution(board, moves) {
    let board1 = [];
    
    // board tranpose
    for (let i = 0; i < board.length; i++) {
        let tmpArr = [];
        for (let j = 0; j < board.length; j++) {
            if (board[j][i] === 0)
                continue;
            tmpArr.push(board[j][i]);
        }
        board1.push(tmpArr);
    }
    
    let basket = [];
    let result = 0;
    
    // moves를 처리하여 인형을 바구니에 추가
    moves.forEach((e, index) => {
        if (board1[e-1] && board1[e-1].length > 0) {
            let item = board1[e-1][0]; // 첫 번째 아이템을 가져옵니다.
            board1[e-1].shift(); // 첫 번째 아이템을 배열에서 제거합니다.
            
            if (basket.length > 0 && basket[basket.length - 1] === item) {
                basket.pop(); // 바구니의 마지막 아이템과 동일하면 제거
                result += 2; // 제거된 인형 수를 2개 증가
            } else {
                basket.push(item); // 그렇지 않으면 바구니에 추가
            }
        }
    });

    return result;
}
```

### 개인적인 회고와 다른 풀이

(풀이 중 힘든 점이 있었다면 왜 힘들었고 어떻게 해결했는지, 아니면 이외의 좋을 것 같은 다른 풀이법이 있다면 같이 작성해주세요)

문제를 읽으면서 느낀 출제 의도는 스택을 알고 있는지, 이중 배열을 다룰 수 있는지에 대해 물어보는 거 같다고 느꼈습니다. 

forEach()를 쓰면서 스택스럽게? 별로 안 풀어 봤는데 이번 기회에 풀어봐서 생각의 영역이 더 넓어진 느낌이었습니다.

### 느낀 점

(풀면서 느낀점 이외에도 기억할 점이나 같이 논의하고 싶은 부분 등이 있다면 자유롭게 적어주세요)

스택스럽게? 푸는 방법 또는 스택을 구현하는 원리를 알고 가야한다고 생각합니다.


## 3

### 문제 - <code>숫자 문자열과 영단어</code>

### 알고리즘 설계

(왜 이렇게 코드를 작성했는지 이유를 적어주세요)

1.	숫자 단어 배열 생성 (alphabet):
	•	alphabet 배열에는 영어로 표현된 숫자 단어들이 0부터 9까지 순서대로 저장되어 있습니다.
2.	각 단어에 대해 반복 (forEach):
	•	alphabet 배열의 각 단어에 대해 반복문을 실행합니다.
	•	word는 숫자를 영어로 표현한 단어를 나타내고, index는 해당 단어가 나타내는 숫자를 의미합니다.
3.	단어를 숫자로 대체 (while 및 replace):
	•	s.includes(word)는 문자열 s에 현재 단어 word가 포함되어 있는지 확인합니다.
	•	포함되어 있는 동안, s.replace(word, index)를 사용하여 단어를 해당 숫자로 대체합니다.
	•	이 작업을 문자열 s에서 해당 단어가 더 이상 발견되지 않을 때까지 반복합니다.
4.	문자열을 숫자로 변환하여 리턴 (Number):
### 풀이 코드

```
function solution(s) {
  // 숫자를 영어로 표현한 단어들을 담은 배열
  const alphabet = ["zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine"];
  
  // 배열의 각 단어에 대해 반복
  alphabet.forEach((word, index) => {
    // 문자열 s에 해당 단어가 포함되어 있는 동안 반복
    while (s.includes(word)) {
      // 단어를 해당 숫자로 대체
      s = s.replace(word, index);
    }
  });

  // 문자열을 숫자로 변환하여 반환
  return Number(s);
}
```

### 개인적인 회고와 다른 풀이

(풀이 중 힘든 점이 있었다면 왜 힘들었고 어떻게 해결했는지, 아니면 이외의 좋을 것 같은 다른 풀이법이 있다면 같이 작성해주세요)



### 느낀 점

(풀면서 느낀점 이외에도 기억할 점이나 같이 논의하고 싶은 부분 등이 있다면 자유롭게 적어주세요)

