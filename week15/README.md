# week15

## 1

### ë¬¸ì œ - <code>161989_ë§ì¹ í•˜ê¸°</code>



### ì•Œê³ ë¦¬ì¦˜ ì„¤ê³„

```cpp
/* ì•„ì´ë””ì–´
    ê°œë…: ê±°ë¦¬ ê³„ì‚°
    ë¡œì§:
        ë§ˆì§€ë§‰ìœ¼ë¡œ í˜ì¸íŠ¸ì¹  í•œ ë¶€ë¶„ì„ ê¸°ì–µí•˜ì—¬ ì´ë¥¼ ê¸°ì¤€ìœ¼ë¡œ ì¹ í•´ì•¼ í•˜ëŠ” ë¶€ë¶„ì„ ì¹ í•œë‹¤.
*/
```



### í’€ì´ ì½”ë“œ

```cpp
#include <string>
#include <vector>

using namespace std;

int solution(int n, int m, vector<int> section)
{
    int count = 0;
    int lastPaintedEnd = 0;
    for (int i : section)
    {
        if (i <= lastPaintedEnd) continue;
        
        count++;
        lastPaintedEnd = i + m - 1;
    }
    
    return count;
}
```

### ê°œì¸ì ì¸ íšŒê³ ì™€ ë‹¤ë¥¸ í’€ì´

ì•„ì´ë””ì–´ë§Œìœ¼ë¡œ ê¹”ë”í•˜ê²Œ êµ¬í˜„ ê°€ëŠ¥í•œ (ì œê°€ ê°œì¸ì ìœ¼ë¡œ ì¢‹ì•„í•˜ëŠ”) ë¬¸ì œì˜€ë˜ ê²ƒ ê°™ìŠµë‹ˆë‹¤! ê±°ë¦¬ ê³„ì‚°ì´ë¼ëŠ” ì•„ì´ë””ì–´ê°€ ë– ì˜¬ë¼ì„œ, ë§ˆì§€ë§‰ìœ¼ë¡œ í˜ì¸íŠ¸ì¹  í•œ ìœ„ì¹˜ë¥¼ ê¸°ì–µí•  ë³€ìˆ˜ë¥¼ í† ëŒ€ë¡œ ì•Œê³ ë¦¬ì¦˜ì„ êµ¬í˜„í–ˆìŠµë‹ˆë‹¤ğŸ˜ğŸ˜


### ëŠë‚€ ì 
í°ì¼“ëª¬ì— ì´ì–´ì„œ ì´ë ‡ê²Œ ì•„ì´ë””ì–´ë§Œìœ¼ë¡œ í’€ ìˆ˜ ìˆëŠ” ë¬¸ì œê°€ ê°€ì¥ ê¹”ë”í•˜ê³  í’€ê¸° í¸í•´ì„œ ì¢‹ì€ ê²ƒ ê°™ì•„ìš”!!

## 2

### ë¬¸ì œ - <code>42889_ì‹¤íŒ¨ìœ¨</code>

### ì•Œê³ ë¦¬ì¦˜ ì„¤ê³„

```cpp
/* flow
    1. ìŠ¤í…Œì´ì§€ë¥¼ í†µê³¼í•˜ì§€ ëª»í•œ í”Œë ˆì´ì–´ì˜ ìˆ˜ë¥¼ ì„¼ë‹¤.
    2. ì´ë¥¼ í† ëŒ€ë¡œ ì‹¤íŒ¨ìœ¨ì„ ì‚°ì •í•œë‹¤.
    3. ì‹¤íŒ¨ìœ¨ì„ í† ëŒ€ë¡œ ë‚´ë¦¼ì°¨ìˆœ ì •ë ¬ì„ í•œë‹¤.
    4. ì‹¤íŒ¨ìœ¨ì´ 0ì´ë¼ë©´ ì˜¤ë¦„ì°¨ìˆœìœ¼ë¡œ 0ì¸ ìŠ¤í…Œì´ì§€ë“¤ë§Œ ì •ë ¬í•œë‹¤.
    5. ì •ë ¬ì´ ëª¨ë‘ ëë‚œ ë°°ì—´ì„ ë°˜í™˜í•œë‹¤.
*/
```



### í’€ì´ ì½”ë“œ

```cpp
#include <string>
#include <vector>
#include <algorithm>
#include <utility>

using namespace std;

vector<int> solution(int N, vector<int> stages)
{
    vector<int> ans(N);
    vector<pair<unsigned, float>> failureRates(N);
    for (int i = 0; i < N; ++i)
    {
        int cnt = count(stages.begin(), stages.end(), i + 1);
        
        failureRates[i].first = i + 1;
        failureRates[i].second = cnt == 0 ? 0 : float(cnt) / count_if(stages.begin(), stages.end(),
                                        [&i] (const int stage) { return stage >= i + 1; });
    }
    
    sort(failureRates.begin(), failureRates.end(),
        [] (const pair<unsigned, float>& r1, const pair<unsigned, float>& r2)
         {
        	if (r1.second == r2.second)
        		return r1.first < r2.first;
        		
            return r1.second > r2.second;
         });
    
    for (int i = 0; i < N; ++i)
        ans[i] = failureRates[i].first;
    
    return ans;
}
```

### ê°œì¸ì ì¸ íšŒê³ ì™€ ë‹¤ë¥¸ í’€ì´

ì‚¬ì‹¤ ì²˜ìŒì—ëŠ” ìƒ˜í”Œ í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤ëŠ” ëª¨ë‘ í†µê³¼í–ˆì§€ë§Œ ì œì¶œí–ˆì„ ë•Œ ì •ë‹µë¥ ì´ 100%ê°€ ë˜ì§ˆ ì•Šì•„ ë¬´ì—‡ì´ ì˜ëª»ëëŠ”ì§€ ê³ ë¯¼ì„ í–ˆì—ˆìŠµë‹ˆë‹¤. ê·¼ë° ìƒê°í•´ë³´ë‹ˆ ë§ˆì§€ë§‰ ìŠ¤í…Œì´ì§€(N)ë¥¼ ì•„ì˜ˆ ëª¨ë“  í”Œë ˆì´ì–´ë“¤ì´ ë„ë‹¬í•˜ì§€ë„ ëª»í•œ ê²½ìš°ë„ ìˆê² ë”ë¼êµ¬ìš”! ë‹¤ì‹œ ë§í•´ **ë¶„ëª¨ë¡œ ê³„ì‚°ë˜ëŠ” ê°’ì´ 0ì¸ ê²½ìš°**ê°€ ì¡´ì¬í•˜ë¯€ë¡œ, ì´ëŸ° ê²½ìš°ë¥¼ ë°©ì§€í•˜ê³ ì ì‚¼í•­ì—°ì‚°ìë¥¼ í†µí•´ ì• ì´ˆì— cntê°€ 0ì¸ ê²½ìš°ì—ëŠ” ì‹¤íŒ¨ìœ¨ ê³„ì‚°ì„ í•˜ì§€ ì•Šê³  ë°”ë¡œ 0ì„ í• ë‹¹í•˜ë„ë¡ ì½”ë“œë¥¼ ìˆ˜ì •í–ˆìŠµë‹ˆë‹¤ğŸ™ƒğŸ™ƒ

### ëŠë‚€ ì 

ì´ë²ˆì— ìŠ¤í„°ë””ì›ë¶„ë“¤ì²˜ëŸ¼ í•¨ìˆ˜ ì§€í–¥ì ìœ¼ë¡œ í”„ë¡œê·¸ë˜ë° í•´ë³´ê³ ì ëŒë‹¤í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•´ë´¤ëŠ”ë°, ë„ˆë¬´ í¸í•˜ê³  ì¢‹ì€ ê²ƒ ê°™ìŠµë‹ˆë‹¤!! ì•ìœ¼ë¡œë„ ì• ìš©í•  ê²ƒ ê°™ì•„ìš” ã…ã…




## 3

### ë¬¸ì œ - <code>160586_ëŒ€ì¶©ë§Œë“ ìíŒ</code>

### ì•Œê³ ë¦¬ì¦˜ ì„¤ê³„

```cpp
/* flow
    1. keymapë“¤ì„ ìˆœíšŒí•˜ë©° target ë¬¸ìì—´ì˜ ë¬¸ìë“¤ì„ ì…ë ¥ê°€ëŠ¥í•œ ì§€ í™•ì¸í•œë‹¤.
    1-1. ì´ ë•Œ, í•˜ë‚˜ë¼ë„ ì…ë ¥í•  ìˆ˜ ì—†ëŠ” ë¬¸ìê°€ ë°œê²¬ë˜ë©´ í•´ë‹¹ target ë¬¸ìì—´ì€ ë„˜ì–´ê°€ë©° -1ì„ ë‹´ì•„ë‘”ë‹¤.
    1-2. ê·¸ê²Œ ì•„ë‹ˆë¼ë©´ keymapë“¤ì„ ëª¨ë‘ ìˆœíšŒí•˜ë©° ë²„íŠ¼ì„ ëˆ„ë¥´ëŠ” ìµœì†Œ íšŸìˆ˜ë¥¼ ë‹´ì•„ë‘”ë‹¤.
    2. ìˆœíšŒê°€ ëª¨ë‘ ëë‚˜ë©´ ìµœì†Œ ì…ë ¥ê°’ë“¤ì„ ë‹´ì€ ë°°ì—´ì„ ë°˜í™˜í•œë‹¤.
*/
```



### í’€ì´ ì½”ë“œ

```cpp
#include <string>
#include <vector>
#include <climits>

#define NOT_FOUND -1

using namespace std;

vector<int> solution(vector<string> keymap, vector<string> targets)
{
    vector<int> minTyping;
    for (string t : targets)
    {
        int count = 0;
        bool found = true;
        for (char c : t)
        {
            int minIndex = INT_MAX;
            for (string k : keymap)
            {
                int currentIndex = k.find(c);
                
                if (currentIndex == string::npos) continue;
                
                minIndex = min(minIndex, currentIndex);
            }
            
            if (minIndex == INT_MAX)
            {
                minTyping.push_back(NOT_FOUND);
                found = false;
                break;
            }
                
            count += (minIndex + 1);
        }
        
        if (found) minTyping.push_back(count);
    }
    
    return minTyping;
}
```

### ê°œì¸ì ì¸ íšŒê³ ì™€ ë‹¤ë¥¸ í’€ì´

ê°œì¸ì ìœ¼ë¡œ ì• ë¨¹ì—ˆë˜ ë¬¸ì œì˜€ìŠµë‹ˆë‹¤. ëª¨ë“  ë¡œì§ì„ ë‹¤ êµ¬í˜„í•˜ê³ , í…ŒìŠ¤íŠ¸ë¥¼ í•´ë´ë„ ê³„ì† ì‹¤íŒ¨ê°€ ë– ì„œ, ë¬´ì—‡ì´ ë¬¸ì œì¸ì§€ ì°¾ëŠë¼ ê³ ìƒì„ í–ˆìŠµë‹ˆë‹¤ğŸ˜­ğŸ˜­ ì•Œê³ ë³´ë‹ˆ minIndexì— ì´ˆê¸°ê°’ìœ¼ë¡œ 0ì„ í• ë‹¹í–ˆì—ˆëŠ”ë°, ì´ë ‡ê²Œ ë˜ë©´ min(minIndex, currentIndex) ì½”ë“œì—ì„œ ë…¼ë¦¬ëŒ€ë¡œ ì œëŒ€ë¡œ ë™ì‘í•˜ì§€ ì•ŠëŠ” ê²½ìš°ê°€ ë°œìƒí•˜ë¯€ë¡œ minIndexì˜ ì´ˆê¸°ê°’ìœ¼ë¡œëŠ” í•´ë‹¹ ìë£Œí˜•ì˜ ìµœëŒ€ê°’ì¸ INT_MAXë¥¼ í• ë‹¹í•´ì£¼ì—ˆìŠµë‹ˆë‹¤! ê·¸ë˜ì„œ ê²°êµ­ ì‘ì„±í•œ ë…¼ë¦¬ íë¦„ëŒ€ë¡œ ì˜ ì‘ë™í–ˆìŠµë‹ˆë‹¤ğŸ¥²


### ëŠë‚€ ì 

ì´ ë¬¸ì œë¥¼ í’€ë©´ì„œ ìµœëŒ€ê°’ê³¼ ìµœì†Œê°’ì„ êµ¬í•  ë•Œ, ì´ˆê¸°ê°’ìœ¼ë¡œ ë¬´ì—‡ì„ í• ë‹¹í•˜ëŠ” ì§€ì— ëŒ€í•´ ë³µìŠµì„ í•˜ê²Œ ëìŠµë‹ˆë‹¤ğŸ«¨
